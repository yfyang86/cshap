# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 /home/thoth/gdurif/softs/bin/swig -c++ -r -o spams.cpp spams.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  assign(defName,  .values,  envir = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################



setClass('C++Reference', contains = 'ExternalReference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressMessages(suppressWarnings(setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})))

# Start of m_ones

`m_ones` = function(nb)
{
  nb = as.integer(nb);
  
  if(length(nb) > 1) {
    warning("using only the first element of nb");
  };
  
  ;ans = .Call('R_swig_m_ones', nb, PACKAGE='spams');
  #ans <- new("_p_int", ref=ans) ;
  
  ans
  
}

attr(`m_ones`, 'returnType') = 'integer'
attr(`m_ones`, "inputTypes") = c('integer')
class(`m_ones`) = c("SWIGFunction", class('m_ones'))

# Start of skip_space

`skip_space` = function(s)
{
  s = as(s, "character"); 
  ;.Call('R_swig_skip_space', s, PACKAGE='spams');
  
}

attr(`skip_space`, 'returnType') = 'character'
attr(`skip_space`, "inputTypes") = c('character')
class(`skip_space`) = c("SWIGFunction", class('skip_space'))

# Start of parse_line

`parse_line` = function(s, vresult, .copy = FALSE)
{
  s = as(s, "character"); 
  if (inherits(vresult, "ExternalReference")) vresult = slot(vresult,"ref") 
  ;.Call('R_swig_parse_line', s, vresult, as.logical(.copy), PACKAGE='spams');
  
}

attr(`parse_line`, 'returnType') = 'integer'
attr(`parse_line`, "inputTypes") = c('character', '_p_std__vectorT_std__string_t')
class(`parse_line`) = c("SWIGFunction", class('parse_line'))

# Start of intlist

`intlist` = function(s)
{
  s = as(s, "character"); 
  ;ans = .Call('R_swig_intlist', s, PACKAGE='spams');
  #ans <- new("_p_std__vectorT_int_t", ref=ans) ;
  
  ans
  
}

attr(`intlist`, 'returnType') = '_p_std__vectorT_int_t'
attr(`intlist`, "inputTypes") = c('character')
class(`intlist`) = c("SWIGFunction", class('intlist'))

# Start of sort

`sort` = function(v, mode)
{
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  mode = as.logical(mode);
  ;.Call('R_swig_sort', v, mode, PACKAGE='spams');
  
}

attr(`sort`, 'returnType') = 'void'
attr(`sort`, "inputTypes") = c('_p_VectorT_double_t', 'logical')
class(`sort`) = c("SWIGFunction", class('sort'))

# Start of mult

`mult` = function(X, Y, XY, transX, transY, a, b)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(Y, "ExternalReference")) Y = slot(Y,"ref") 
  if (inherits(XY, "ExternalReference")) XY = slot(XY,"ref") 
  transX = as.logical(transX);
  transY = as.logical(transY);
  
  
  ;.Call('R_swig_mult', X, Y, XY, transX, transY, a, b, PACKAGE='spams');
  
}

attr(`mult`, 'returnType') = 'void'
attr(`mult`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_MatrixT_double_t', 'logical', 'logical', 'numeric', 'numeric')
class(`mult`) = c("SWIGFunction", class('mult'))

# Start of AAt

`AAt` = function(A, B)
{
  if (inherits(A, "ExternalReference")) A = slot(A,"ref") 
  if (inherits(B, "ExternalReference")) B = slot(B,"ref") 
  ;.Call('R_swig_AAt', A, B, PACKAGE='spams');
  
}

attr(`AAt`, 'returnType') = 'void'
attr(`AAt`, "inputTypes") = c('_p_SpMatrixT_double_t', '_p_MatrixT_double_t')
class(`AAt`) = c("SWIGFunction", class('AAt'))

# Start of XAt

`XAt` = function(A, X, XAt)
{
  if (inherits(A, "ExternalReference")) A = slot(A,"ref") 
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(XAt, "ExternalReference")) XAt = slot(XAt,"ref") 
  ;.Call('R_swig_XAt', A, X, XAt, PACKAGE='spams');
  
}

attr(`XAt`, 'returnType') = 'void'
attr(`XAt`, "inputTypes") = c('_p_SpMatrixT_double_t', '_p_MatrixT_double_t', '_p_MatrixT_double_t')
class(`XAt`) = c("SWIGFunction", class('XAt'))

# Start of applyBayerPattern

`applyBayerPattern` = function(v, offset)
{
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  offset = as.integer(offset);
  
  if(length(offset) > 1) {
    warning("using only the first element of offset");
  };
  
  ;.Call('R_swig_applyBayerPattern', v, offset, PACKAGE='spams');
  
}

attr(`applyBayerPattern`, 'returnType') = 'void'
attr(`applyBayerPattern`, "inputTypes") = c('_p_VectorT_double_t', 'integer')
class(`applyBayerPattern`) = c("SWIGFunction", class('applyBayerPattern'))

# Start of conjugateGradient

`conjugateGradient` = function(A, b, x, tol, itermax)
{
  if (inherits(A, "ExternalReference")) A = slot(A,"ref") 
  if (inherits(b, "ExternalReference")) b = slot(b,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  
  itermax = as.integer(itermax);
  
  if(length(itermax) > 1) {
    warning("using only the first element of itermax");
  };
  
  ;.Call('R_swig_conjugateGradient', A, b, x, tol, itermax, PACKAGE='spams');
  
}

attr(`conjugateGradient`, 'returnType') = 'void'
attr(`conjugateGradient`, "inputTypes") = c('_p_MatrixT_double_t', '_p_VectorT_double_t', '_p_VectorT_double_t', 'numeric', 'integer')
class(`conjugateGradient`) = c("SWIGFunction", class('conjugateGradient'))

# Start of invSym

`invSym` = function(A)
{
  if (inherits(A, "ExternalReference")) A = slot(A,"ref") 
  ;.Call('R_swig_invSym', A, PACKAGE='spams');
  
}

attr(`invSym`, 'returnType') = 'void'
attr(`invSym`, "inputTypes") = c('_p_MatrixT_double_t')
class(`invSym`) = c("SWIGFunction", class('invSym'))

# Start of normalize

`normalize` = function(A)
{
  if (inherits(A, "ExternalReference")) A = slot(A,"ref") 
  ;.Call('R_swig_normalize', A, PACKAGE='spams');
  
}

attr(`normalize`, 'returnType') = 'void'
attr(`normalize`, "inputTypes") = c('_p_MatrixT_double_t')
class(`normalize`) = c("SWIGFunction", class('normalize'))

defineEnumeration('_constraint_type',
                    .values = c(
                        'L1COEFFS' = 0, 
                        'L2ERROR' = 1, 
                        'PENALTY' = 2, 
                        'SPARSITY' = 3, 
                        'L2ERROR2' = 4, 
                        'PENALTY2' = 5, 
                        'FISTAMODE' = 6
))
# Start of sparseProject

`sparseProject` = function(U, V, thrs, mode, lambda1, lambda2, lambda3, pos, numThreads)
{
  if (inherits(U, "ExternalReference")) U = slot(U,"ref") 
  if (inherits(V, "ExternalReference")) V = slot(V,"ref") 
  
  mode = as.integer(mode);
  
  if(length(mode) > 1) {
    warning("using only the first element of mode");
  };
  
  
  
  
  pos = as.logical(pos);
  numThreads = as.integer(numThreads);
  
  if(length(numThreads) > 1) {
    warning("using only the first element of numThreads");
  };
  
  ;.Call('R_swig_sparseProject', U, V, thrs, mode, lambda1, lambda2, lambda3, pos, numThreads, PACKAGE='spams');
  
}

attr(`sparseProject`, 'returnType') = 'void'
attr(`sparseProject`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', 'numeric', 'integer', 'numeric', 'numeric', 'numeric', 'logical', 'integer')
class(`sparseProject`) = c("SWIGFunction", class('sparseProject'))

# Start of lassoD

`lassoD` = function(X, D, return_reg_path, L, constraint, lambda2, mode, pos, ols, numThreads, max_length_path, verbose, cholevsky)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(D, "ExternalReference")) D = slot(D,"ref") 
  return_reg_path = as.logical(return_reg_path);
  L = as.integer(L);
  
  if(length(L) > 1) {
    warning("using only the first element of L");
  };
  
  
  
  mode = enumToInteger(mode, "_constraint_type"); 
  
  if(length(mode) > 1) {
    warning("using only the first element of mode");
  };
  
  pos = as.logical(pos);
  ols = as.logical(ols);
  numThreads = as.integer(numThreads);
  
  if(length(numThreads) > 1) {
    warning("using only the first element of numThreads");
  };
  
  max_length_path = as.integer(max_length_path);
  
  if(length(max_length_path) > 1) {
    warning("using only the first element of max_length_path");
  };
  
  verbose = as.logical(verbose);
  cholevsky = as.logical(cholevsky);
  ;ans = .Call('R_swig_lassoD', X, D, return_reg_path, L, constraint, lambda2, mode, pos, ols, numThreads, max_length_path, verbose, cholevsky, PACKAGE='spams');
  #ans <- new("_p_SpMatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`lassoD`, 'returnType') = '_p_SpMatrixT_double_t'
attr(`lassoD`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', 'logical', 'integer', 'numeric', 'numeric', 'character', 'logical', 'logical', 'integer', 'integer', 'logical', 'logical')
class(`lassoD`) = c("SWIGFunction", class('lassoD'))

# Start of lassoQq

`lassoQq` = function(X, Q, q, return_reg_path, L, constraint, lambda2, mode, pos, ols, numThreads, max_length_path, verbose, cholevsky)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(Q, "ExternalReference")) Q = slot(Q,"ref") 
  if (inherits(q, "ExternalReference")) q = slot(q,"ref") 
  return_reg_path = as.logical(return_reg_path);
  L = as.integer(L);
  
  if(length(L) > 1) {
    warning("using only the first element of L");
  };
  
  
  
  mode = enumToInteger(mode, "_constraint_type"); 
  
  if(length(mode) > 1) {
    warning("using only the first element of mode");
  };
  
  pos = as.logical(pos);
  ols = as.logical(ols);
  numThreads = as.integer(numThreads);
  
  if(length(numThreads) > 1) {
    warning("using only the first element of numThreads");
  };
  
  max_length_path = as.integer(max_length_path);
  
  if(length(max_length_path) > 1) {
    warning("using only the first element of max_length_path");
  };
  
  verbose = as.logical(verbose);
  cholevsky = as.logical(cholevsky);
  ;ans = .Call('R_swig_lassoQq', X, Q, q, return_reg_path, L, constraint, lambda2, mode, pos, ols, numThreads, max_length_path, verbose, cholevsky, PACKAGE='spams');
  #ans <- new("_p_SpMatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`lassoQq`, 'returnType') = '_p_SpMatrixT_double_t'
attr(`lassoQq`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_MatrixT_double_t', 'logical', 'integer', 'numeric', 'numeric', 'character', 'logical', 'logical', 'integer', 'integer', 'logical', 'logical')
class(`lassoQq`) = c("SWIGFunction", class('lassoQq'))

# Start of lassoMask

`lassoMask` = function(X, D, B, L, constraint, lambda2, mode, pos, numThreads, verbose)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(D, "ExternalReference")) D = slot(D,"ref") 
  if (inherits(B, "ExternalReference")) B = slot(B,"ref") 
  L = as.integer(L);
  
  if(length(L) > 1) {
    warning("using only the first element of L");
  };
  
  
  
  mode = enumToInteger(mode, "_constraint_type"); 
  
  if(length(mode) > 1) {
    warning("using only the first element of mode");
  };
  
  pos = as.logical(pos);
  numThreads = as.integer(numThreads);
  
  if(length(numThreads) > 1) {
    warning("using only the first element of numThreads");
  };
  
  verbose = as.logical(verbose);
  ;ans = .Call('R_swig_lassoMask', X, D, B, L, constraint, lambda2, mode, pos, numThreads, verbose, PACKAGE='spams');
  #ans <- new("_p_SpMatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`lassoMask`, 'returnType') = '_p_SpMatrixT_double_t'
attr(`lassoMask`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_MatrixT_bool_t', 'integer', 'numeric', 'numeric', 'character', 'logical', 'integer', 'logical')
class(`lassoMask`) = c("SWIGFunction", class('lassoMask'))

# Start of lassoWeighted

`lassoWeighted` = function(X, D, W, L, constraint, mode, pos, numThreads, verbose)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(D, "ExternalReference")) D = slot(D,"ref") 
  if (inherits(W, "ExternalReference")) W = slot(W,"ref") 
  L = as.integer(L);
  
  if(length(L) > 1) {
    warning("using only the first element of L");
  };
  
  
  mode = enumToInteger(mode, "_constraint_type"); 
  
  if(length(mode) > 1) {
    warning("using only the first element of mode");
  };
  
  pos = as.logical(pos);
  numThreads = as.integer(numThreads);
  
  if(length(numThreads) > 1) {
    warning("using only the first element of numThreads");
  };
  
  verbose = as.logical(verbose);
  ;ans = .Call('R_swig_lassoWeighted', X, D, W, L, constraint, mode, pos, numThreads, verbose, PACKAGE='spams');
  #ans <- new("_p_SpMatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`lassoWeighted`, 'returnType') = '_p_SpMatrixT_double_t'
attr(`lassoWeighted`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_MatrixT_double_t', 'integer', 'numeric', 'character', 'logical', 'integer', 'logical')
class(`lassoWeighted`) = c("SWIGFunction", class('lassoWeighted'))

# Start of omp

`omp` = function(X, D, return_reg_path, given_L, L, given_eps, eps, given_Lambda, Lambda, numThreads)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(D, "ExternalReference")) D = slot(D,"ref") 
  return_reg_path = as.logical(return_reg_path);
  given_L = as.logical(given_L);
  if (inherits(L, "ExternalReference")) L = slot(L,"ref") 
  given_eps = as.logical(given_eps);
  if (inherits(eps, "ExternalReference")) eps = slot(eps,"ref") 
  given_Lambda = as.logical(given_Lambda);
  if (inherits(Lambda, "ExternalReference")) Lambda = slot(Lambda,"ref") 
  numThreads = as.integer(numThreads);
  
  if(length(numThreads) > 1) {
    warning("using only the first element of numThreads");
  };
  
  ;ans = .Call('R_swig_omp', X, D, return_reg_path, given_L, L, given_eps, eps, given_Lambda, Lambda, numThreads, PACKAGE='spams');
  #ans <- new("_p_SpMatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`omp`, 'returnType') = '_p_SpMatrixT_double_t'
attr(`omp`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', 'logical', 'logical', '_p_VectorT_int_t', 'logical', '_p_VectorT_double_t', 'logical', '_p_VectorT_double_t', 'integer')
class(`omp`) = c("SWIGFunction", class('omp'))

# Start of ompMask

`ompMask` = function(X, D, B, return_reg_path, given_L, L, given_eps, eps, given_Lambda, Lambda, numThreads)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(D, "ExternalReference")) D = slot(D,"ref") 
  if (inherits(B, "ExternalReference")) B = slot(B,"ref") 
  return_reg_path = as.logical(return_reg_path);
  given_L = as.logical(given_L);
  if (inherits(L, "ExternalReference")) L = slot(L,"ref") 
  given_eps = as.logical(given_eps);
  if (inherits(eps, "ExternalReference")) eps = slot(eps,"ref") 
  given_Lambda = as.logical(given_Lambda);
  if (inherits(Lambda, "ExternalReference")) Lambda = slot(Lambda,"ref") 
  numThreads = as.integer(numThreads);
  
  if(length(numThreads) > 1) {
    warning("using only the first element of numThreads");
  };
  
  ;ans = .Call('R_swig_ompMask', X, D, B, return_reg_path, given_L, L, given_eps, eps, given_Lambda, Lambda, numThreads, PACKAGE='spams');
  #ans <- new("_p_SpMatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`ompMask`, 'returnType') = '_p_SpMatrixT_double_t'
attr(`ompMask`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_MatrixT_bool_t', 'logical', 'logical', '_p_VectorT_int_t', 'logical', '_p_VectorT_double_t', 'logical', '_p_VectorT_double_t', 'integer')
class(`ompMask`) = c("SWIGFunction", class('ompMask'))

# Start of somp

`somp` = function(X, D, groups, LL, eps, numThreads)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(D, "ExternalReference")) D = slot(D,"ref") 
  if (inherits(groups, "ExternalReference")) groups = slot(groups,"ref") 
  LL = as.integer(LL);
  
  if(length(LL) > 1) {
    warning("using only the first element of LL");
  };
  
  
  numThreads = as.integer(numThreads);
  
  if(length(numThreads) > 1) {
    warning("using only the first element of numThreads");
  };
  
  ;ans = .Call('R_swig_somp', X, D, groups, LL, eps, numThreads, PACKAGE='spams');
  #ans <- new("_p_SpMatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`somp`, 'returnType') = '_p_SpMatrixT_double_t'
attr(`somp`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_VectorT_int_t', 'integer', 'numeric', 'integer')
class(`somp`) = c("SWIGFunction", class('somp'))

# Start of cd

`cd` = function(X, D, alpha, lambda1, mode, itermax, tol, numThreads)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(D, "ExternalReference")) D = slot(D,"ref") 
  if (inherits(alpha, "ExternalReference")) alpha = slot(alpha,"ref") 
  
  mode = enumToInteger(mode, "_constraint_type"); 
  
  if(length(mode) > 1) {
    warning("using only the first element of mode");
  };
  
  itermax = as.integer(itermax);
  
  if(length(itermax) > 1) {
    warning("using only the first element of itermax");
  };
  
  
  numThreads = as.integer(numThreads);
  
  if(length(numThreads) > 1) {
    warning("using only the first element of numThreads");
  };
  
  ;ans = .Call('R_swig_cd', X, D, alpha, lambda1, mode, itermax, tol, numThreads, PACKAGE='spams');
  #ans <- new("_p_SpMatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`cd`, 'returnType') = '_p_SpMatrixT_double_t'
attr(`cd`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_SpMatrixT_double_t', 'numeric', 'character', 'integer', 'numeric', 'integer')
class(`cd`) = c("SWIGFunction", class('cd'))

# Start of l1L2BCD

`l1L2BCD` = function(X, D, alpha0, groups, lambda1, mode, itermax, tol, numThreads)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(D, "ExternalReference")) D = slot(D,"ref") 
  if (inherits(alpha0, "ExternalReference")) alpha0 = slot(alpha0,"ref") 
  if (inherits(groups, "ExternalReference")) groups = slot(groups,"ref") 
  
  mode = enumToInteger(mode, "_constraint_type"); 
  
  if(length(mode) > 1) {
    warning("using only the first element of mode");
  };
  
  itermax = as.integer(itermax);
  
  if(length(itermax) > 1) {
    warning("using only the first element of itermax");
  };
  
  
  numThreads = as.integer(numThreads);
  
  if(length(numThreads) > 1) {
    warning("using only the first element of numThreads");
  };
  
  ;.Call('R_swig_l1L2BCD', X, D, alpha0, groups, lambda1, mode, itermax, tol, numThreads, PACKAGE='spams');
  
}

attr(`l1L2BCD`, 'returnType') = 'void'
attr(`l1L2BCD`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_VectorT_int_t', 'numeric', 'character', 'integer', 'numeric', 'integer')
class(`l1L2BCD`) = c("SWIGFunction", class('l1L2BCD'))

defineEnumeration('_constraint_type_D',
                    .values = c(
                        'L2' = 0, 
                        'L1L2' = 1, 
                        'L1L2FL' = 2, 
                        'L1L2MU' = 3
))
# Start of alltrainDL

`alltrainDL` = function(X, in_memory, return_model, m_A, m_B, m_iter, D1, eta_g, groups, groups_var, own_variables, N_own_variables, num_threads, tol, fixed_step, ista, batch_size, K, lambda1, lambda2, lambda3, iter, t0, mode, name_regul, posAlpha, posD, expand, modeD, whiten, clean, verbose, gamma1, gamma2, rho, iter_updateD, stochastic, modeParam, batch, log, logName)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  in_memory = as.logical(in_memory);
  return_model = as.logical(return_model);
  if (inherits(m_A, "ExternalReference")) m_A = slot(m_A,"ref") 
  if (inherits(m_B, "ExternalReference")) m_B = slot(m_B,"ref") 
  m_iter = as.integer(m_iter);
  
  if(length(m_iter) > 1) {
    warning("using only the first element of m_iter");
  };
  
  if (inherits(D1, "ExternalReference")) D1 = slot(D1,"ref") 
  if (inherits(eta_g, "ExternalReference")) eta_g = slot(eta_g,"ref") 
  if (inherits(groups, "ExternalReference")) groups = slot(groups,"ref") 
  if (inherits(groups_var, "ExternalReference")) groups_var = slot(groups_var,"ref") 
  if (inherits(own_variables, "ExternalReference")) own_variables = slot(own_variables,"ref") 
  if (inherits(N_own_variables, "ExternalReference")) N_own_variables = slot(N_own_variables,"ref") 
  num_threads = as.integer(num_threads);
  
  if(length(num_threads) > 1) {
    warning("using only the first element of num_threads");
  };
  
  
  fixed_step = as.logical(fixed_step);
  ista = as.logical(ista);
  batch_size = as.integer(batch_size);
  
  if(length(batch_size) > 1) {
    warning("using only the first element of batch_size");
  };
  
  K = as.integer(K);
  
  if(length(K) > 1) {
    warning("using only the first element of K");
  };
  
  
  
  
  iter = as.integer(iter);
  
  if(length(iter) > 1) {
    warning("using only the first element of iter");
  };
  
  
  mode = enumToInteger(mode, "_constraint_type"); 
  
  if(length(mode) > 1) {
    warning("using only the first element of mode");
  };
  
  name_regul = as(name_regul, "character"); 
  posAlpha = as.logical(posAlpha);
  posD = as.logical(posD);
  expand = as.logical(expand);
  modeD = enumToInteger(modeD, "_constraint_type_D"); 
  
  if(length(modeD) > 1) {
    warning("using only the first element of modeD");
  };
  
  whiten = as.logical(whiten);
  clean = as.logical(clean);
  verbose = as.logical(verbose);
  
  
  
  iter_updateD = as.integer(iter_updateD);
  
  if(length(iter_updateD) > 1) {
    warning("using only the first element of iter_updateD");
  };
  
  stochastic = as.logical(stochastic);
  modeParam = as.integer(modeParam);
  
  if(length(modeParam) > 1) {
    warning("using only the first element of modeParam");
  };
  
  batch = as.logical(batch);
  log = as.logical(log);
  logName = as(logName, "character"); 
  ;ans = .Call('R_swig_alltrainDL', X, in_memory, return_model, m_A, m_B, m_iter, D1, eta_g, groups, groups_var, own_variables, N_own_variables, num_threads, tol, fixed_step, ista, batch_size, K, lambda1, lambda2, lambda3, iter, t0, mode, name_regul, posAlpha, posD, expand, modeD, whiten, clean, verbose, gamma1, gamma2, rho, iter_updateD, stochastic, modeParam, batch, log, logName, PACKAGE='spams');
  #ans <- new("_p_MatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`alltrainDL`, 'returnType') = '_p_MatrixT_double_t'
attr(`alltrainDL`, "inputTypes") = c('_p_DataT_double_t', 'logical', 'logical', '_p_MatrixT_double_t', '_p_MatrixT_double_t', 'integer', '_p_MatrixT_double_t', '_p_VectorT_double_t', '_p_SpMatrixT_bool_t', '_p_SpMatrixT_bool_t', '_p_VectorT_int_t', '_p_VectorT_int_t', 'integer', 'numeric', 'logical', 'logical', 'integer', 'integer', 'numeric', 'numeric', 'numeric', 'integer', 'numeric', 'character', 'character', 'logical', 'logical', 'logical', 'character', 'logical', 'logical', 'logical', 'numeric', 'numeric', 'numeric', 'integer', 'logical', 'integer', 'logical', 'logical', 'character')
class(`alltrainDL`) = c("SWIGFunction", class('alltrainDL'))

# Start of archetypalAnalysis

`archetypalAnalysis` = function(X, p, robust, epsilon, computeXtX, stepsFISTA, stepsAS, randominit, numThreads)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  p = as.integer(p);
  
  if(length(p) > 1) {
    warning("using only the first element of p");
  };
  
  robust = as.logical(robust);
  
  computeXtX = as.logical(computeXtX);
  stepsFISTA = as.integer(stepsFISTA);
  
  if(length(stepsFISTA) > 1) {
    warning("using only the first element of stepsFISTA");
  };
  
  stepsAS = as.integer(stepsAS);
  
  if(length(stepsAS) > 1) {
    warning("using only the first element of stepsAS");
  };
  
  randominit = as.logical(randominit);
  numThreads = as.integer(numThreads);
  
  if(length(numThreads) > 1) {
    warning("using only the first element of numThreads");
  };
  
  ;ans = .Call('R_swig_archetypalAnalysis', X, p, robust, epsilon, computeXtX, stepsFISTA, stepsAS, randominit, numThreads, PACKAGE='spams');
  #ans <- new("_p_MatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`archetypalAnalysis`, 'returnType') = '_p_MatrixT_double_t'
attr(`archetypalAnalysis`, "inputTypes") = c('_p_MatrixT_double_t', 'integer', 'logical', 'numeric', 'logical', 'integer', 'integer', 'logical', 'integer')
class(`archetypalAnalysis`) = c("SWIGFunction", class('archetypalAnalysis'))

# Start of archetypalAnalysisInit

`archetypalAnalysisInit` = function(X, Z0, robust, epsilon, computeXtX, stepsFISTA, stepsAS, numThreads)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(Z0, "ExternalReference")) Z0 = slot(Z0,"ref") 
  robust = as.logical(robust);
  
  computeXtX = as.logical(computeXtX);
  stepsFISTA = as.integer(stepsFISTA);
  
  if(length(stepsFISTA) > 1) {
    warning("using only the first element of stepsFISTA");
  };
  
  stepsAS = as.integer(stepsAS);
  
  if(length(stepsAS) > 1) {
    warning("using only the first element of stepsAS");
  };
  
  numThreads = as.integer(numThreads);
  
  if(length(numThreads) > 1) {
    warning("using only the first element of numThreads");
  };
  
  ;ans = .Call('R_swig_archetypalAnalysisInit', X, Z0, robust, epsilon, computeXtX, stepsFISTA, stepsAS, numThreads, PACKAGE='spams');
  #ans <- new("_p_MatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`archetypalAnalysisInit`, 'returnType') = '_p_MatrixT_double_t'
attr(`archetypalAnalysisInit`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', 'logical', 'numeric', 'logical', 'integer', 'integer', 'integer')
class(`archetypalAnalysisInit`) = c("SWIGFunction", class('archetypalAnalysisInit'))

# Start of decompSimplex

`decompSimplex` = function(X, Z, computeXtX, numThreads)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(Z, "ExternalReference")) Z = slot(Z,"ref") 
  computeXtX = as.logical(computeXtX);
  numThreads = as.integer(numThreads);
  
  if(length(numThreads) > 1) {
    warning("using only the first element of numThreads");
  };
  
  ;ans = .Call('R_swig_decompSimplex', X, Z, computeXtX, numThreads, PACKAGE='spams');
  #ans <- new("_p_SpMatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`decompSimplex`, 'returnType') = '_p_SpMatrixT_double_t'
attr(`decompSimplex`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', 'logical', 'integer')
class(`decompSimplex`) = c("SWIGFunction", class('decompSimplex'))

# Start of fistaFlat

`fistaFlat` = function(X, D, alpha0, alpha, groups, num_threads, max_it, L0, fixed_step, gamma, s_lambda, delta, lambda2, lambda3, a, b, c, tol, it0, max_iter_backtracking, compute_gram, lin_admm, admm, intercept, resetflow, name_regul, name_loss, verbose, pos, clever, log, ista, subgrad, logName, is_inner_weights, inner_weights, size_group, sqrt_step, transpose, linesearch_mode)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(D, "ExternalReference")) D = slot(D,"ref") 
  if (inherits(alpha0, "ExternalReference")) alpha0 = slot(alpha0,"ref") 
  if (inherits(alpha, "ExternalReference")) alpha = slot(alpha,"ref") 
  if (inherits(groups, "ExternalReference")) groups = slot(groups,"ref") 
  num_threads = as.integer(num_threads);
  
  if(length(num_threads) > 1) {
    warning("using only the first element of num_threads");
  };
  
  max_it = as.integer(max_it);
  
  if(length(max_it) > 1) {
    warning("using only the first element of max_it");
  };
  
  
  fixed_step = as.logical(fixed_step);
  
  
  
  
  
  
  
  
  
  it0 = as.integer(it0);
  
  if(length(it0) > 1) {
    warning("using only the first element of it0");
  };
  
  max_iter_backtracking = as.integer(max_iter_backtracking);
  
  if(length(max_iter_backtracking) > 1) {
    warning("using only the first element of max_iter_backtracking");
  };
  
  compute_gram = as.logical(compute_gram);
  lin_admm = as.logical(lin_admm);
  admm = as.logical(admm);
  intercept = as.logical(intercept);
  resetflow = as.logical(resetflow);
  name_regul = as(name_regul, "character"); 
  name_loss = as(name_loss, "character"); 
  verbose = as.logical(verbose);
  pos = as.logical(pos);
  clever = as.logical(clever);
  log = as.logical(log);
  ista = as.logical(ista);
  subgrad = as.logical(subgrad);
  logName = as(logName, "character"); 
  is_inner_weights = as.logical(is_inner_weights);
  if (inherits(inner_weights, "ExternalReference")) inner_weights = slot(inner_weights,"ref") 
  size_group = as.integer(size_group);
  
  if(length(size_group) > 1) {
    warning("using only the first element of size_group");
  };
  
  sqrt_step = as.logical(sqrt_step);
  transpose = as.logical(transpose);
  linesearch_mode = as.integer(linesearch_mode);
  
  if(length(linesearch_mode) > 1) {
    warning("using only the first element of linesearch_mode");
  };
  
  ;ans = .Call('R_swig_fistaFlat', X, D, alpha0, alpha, groups, num_threads, max_it, L0, fixed_step, gamma, s_lambda, delta, lambda2, lambda3, a, b, c, tol, it0, max_iter_backtracking, compute_gram, lin_admm, admm, intercept, resetflow, name_regul, name_loss, verbose, pos, clever, log, ista, subgrad, logName, is_inner_weights, inner_weights, size_group, sqrt_step, transpose, linesearch_mode, PACKAGE='spams');
  #ans <- new("_p_MatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`fistaFlat`, 'returnType') = '_p_MatrixT_double_t'
attr(`fistaFlat`, "inputTypes") = c('_p_MatrixT_double_t', '_p_AbstractMatrixBT_double_t', '_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_VectorT_int_t', 'integer', 'integer', 'numeric', 'logical', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'integer', 'integer', 'logical', 'logical', 'logical', 'logical', 'logical', 'character', 'character', 'logical', 'logical', 'logical', 'logical', 'logical', 'logical', 'character', 'logical', '_p_VectorT_double_t', 'integer', 'logical', 'logical', 'integer')
class(`fistaFlat`) = c("SWIGFunction", class('fistaFlat'))

# Start of fistaTree

`fistaTree` = function(X, D, alpha0, alpha, eta_g, groups, own_variables, N_own_variables, num_threads, max_it, L0, fixed_step, gamma, s_lambda, delta, lambda2, lambda3, a, b, c, tol, it0, max_iter_backtracking, compute_gram, lin_admm, admm, intercept, resetflow, name_regul, name_loss, verbose, pos, clever, log, ista, subgrad, logName, is_inner_weights, inner_weights, size_group, sqrt_step, transpose, linesearch_mode)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(D, "ExternalReference")) D = slot(D,"ref") 
  if (inherits(alpha0, "ExternalReference")) alpha0 = slot(alpha0,"ref") 
  if (inherits(alpha, "ExternalReference")) alpha = slot(alpha,"ref") 
  if (inherits(eta_g, "ExternalReference")) eta_g = slot(eta_g,"ref") 
  if (inherits(groups, "ExternalReference")) groups = slot(groups,"ref") 
  if (inherits(own_variables, "ExternalReference")) own_variables = slot(own_variables,"ref") 
  if (inherits(N_own_variables, "ExternalReference")) N_own_variables = slot(N_own_variables,"ref") 
  num_threads = as.integer(num_threads);
  
  if(length(num_threads) > 1) {
    warning("using only the first element of num_threads");
  };
  
  max_it = as.integer(max_it);
  
  if(length(max_it) > 1) {
    warning("using only the first element of max_it");
  };
  
  
  fixed_step = as.logical(fixed_step);
  
  
  
  
  
  
  
  
  
  it0 = as.integer(it0);
  
  if(length(it0) > 1) {
    warning("using only the first element of it0");
  };
  
  max_iter_backtracking = as.integer(max_iter_backtracking);
  
  if(length(max_iter_backtracking) > 1) {
    warning("using only the first element of max_iter_backtracking");
  };
  
  compute_gram = as.logical(compute_gram);
  lin_admm = as.logical(lin_admm);
  admm = as.logical(admm);
  intercept = as.logical(intercept);
  resetflow = as.logical(resetflow);
  name_regul = as(name_regul, "character"); 
  name_loss = as(name_loss, "character"); 
  verbose = as.logical(verbose);
  pos = as.logical(pos);
  clever = as.logical(clever);
  log = as.logical(log);
  ista = as.logical(ista);
  subgrad = as.logical(subgrad);
  logName = as(logName, "character"); 
  is_inner_weights = as.logical(is_inner_weights);
  if (inherits(inner_weights, "ExternalReference")) inner_weights = slot(inner_weights,"ref") 
  size_group = as.integer(size_group);
  
  if(length(size_group) > 1) {
    warning("using only the first element of size_group");
  };
  
  sqrt_step = as.logical(sqrt_step);
  transpose = as.logical(transpose);
  linesearch_mode = as.integer(linesearch_mode);
  
  if(length(linesearch_mode) > 1) {
    warning("using only the first element of linesearch_mode");
  };
  
  ;ans = .Call('R_swig_fistaTree', X, D, alpha0, alpha, eta_g, groups, own_variables, N_own_variables, num_threads, max_it, L0, fixed_step, gamma, s_lambda, delta, lambda2, lambda3, a, b, c, tol, it0, max_iter_backtracking, compute_gram, lin_admm, admm, intercept, resetflow, name_regul, name_loss, verbose, pos, clever, log, ista, subgrad, logName, is_inner_weights, inner_weights, size_group, sqrt_step, transpose, linesearch_mode, PACKAGE='spams');
  #ans <- new("_p_MatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`fistaTree`, 'returnType') = '_p_MatrixT_double_t'
attr(`fistaTree`, "inputTypes") = c('_p_MatrixT_double_t', '_p_AbstractMatrixBT_double_t', '_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_VectorT_double_t', '_p_SpMatrixT_bool_t', '_p_VectorT_int_t', '_p_VectorT_int_t', 'integer', 'integer', 'numeric', 'logical', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'integer', 'integer', 'logical', 'logical', 'logical', 'logical', 'logical', 'character', 'character', 'logical', 'logical', 'logical', 'logical', 'logical', 'logical', 'character', 'logical', '_p_VectorT_double_t', 'integer', 'logical', 'logical', 'integer')
class(`fistaTree`) = c("SWIGFunction", class('fistaTree'))

# Start of fistaGraph

`fistaGraph` = function(X, D, alpha0, alpha, eta_g, groups, groups_var, num_threads, max_it, L0, fixed_step, gamma, s_lambda, delta, lambda2, lambda3, a, b, c, tol, it0, max_iter_backtracking, compute_gram, lin_admm, admm, intercept, resetflow, name_regul, name_loss, verbose, pos, clever, log, ista, subgrad, logName, is_inner_weights, inner_weights, size_group, sqrt_step, transpose, linesearch_mode)
{
  if (inherits(X, "ExternalReference")) X = slot(X,"ref") 
  if (inherits(D, "ExternalReference")) D = slot(D,"ref") 
  if (inherits(alpha0, "ExternalReference")) alpha0 = slot(alpha0,"ref") 
  if (inherits(alpha, "ExternalReference")) alpha = slot(alpha,"ref") 
  if (inherits(eta_g, "ExternalReference")) eta_g = slot(eta_g,"ref") 
  if (inherits(groups, "ExternalReference")) groups = slot(groups,"ref") 
  if (inherits(groups_var, "ExternalReference")) groups_var = slot(groups_var,"ref") 
  num_threads = as.integer(num_threads);
  
  if(length(num_threads) > 1) {
    warning("using only the first element of num_threads");
  };
  
  max_it = as.integer(max_it);
  
  if(length(max_it) > 1) {
    warning("using only the first element of max_it");
  };
  
  
  fixed_step = as.logical(fixed_step);
  
  
  
  
  
  
  
  
  
  it0 = as.integer(it0);
  
  if(length(it0) > 1) {
    warning("using only the first element of it0");
  };
  
  max_iter_backtracking = as.integer(max_iter_backtracking);
  
  if(length(max_iter_backtracking) > 1) {
    warning("using only the first element of max_iter_backtracking");
  };
  
  compute_gram = as.logical(compute_gram);
  lin_admm = as.logical(lin_admm);
  admm = as.logical(admm);
  intercept = as.logical(intercept);
  resetflow = as.logical(resetflow);
  name_regul = as(name_regul, "character"); 
  name_loss = as(name_loss, "character"); 
  verbose = as.logical(verbose);
  pos = as.logical(pos);
  clever = as.logical(clever);
  log = as.logical(log);
  ista = as.logical(ista);
  subgrad = as.logical(subgrad);
  logName = as(logName, "character"); 
  is_inner_weights = as.logical(is_inner_weights);
  if (inherits(inner_weights, "ExternalReference")) inner_weights = slot(inner_weights,"ref") 
  size_group = as.integer(size_group);
  
  if(length(size_group) > 1) {
    warning("using only the first element of size_group");
  };
  
  sqrt_step = as.logical(sqrt_step);
  transpose = as.logical(transpose);
  linesearch_mode = as.integer(linesearch_mode);
  
  if(length(linesearch_mode) > 1) {
    warning("using only the first element of linesearch_mode");
  };
  
  ;ans = .Call('R_swig_fistaGraph', X, D, alpha0, alpha, eta_g, groups, groups_var, num_threads, max_it, L0, fixed_step, gamma, s_lambda, delta, lambda2, lambda3, a, b, c, tol, it0, max_iter_backtracking, compute_gram, lin_admm, admm, intercept, resetflow, name_regul, name_loss, verbose, pos, clever, log, ista, subgrad, logName, is_inner_weights, inner_weights, size_group, sqrt_step, transpose, linesearch_mode, PACKAGE='spams');
  #ans <- new("_p_MatrixT_double_t", ref=ans) ;
  
  ans
  
}

attr(`fistaGraph`, 'returnType') = '_p_MatrixT_double_t'
attr(`fistaGraph`, "inputTypes") = c('_p_MatrixT_double_t', '_p_AbstractMatrixBT_double_t', '_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_VectorT_double_t', '_p_SpMatrixT_bool_t', '_p_SpMatrixT_bool_t', 'integer', 'integer', 'numeric', 'logical', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'integer', 'integer', 'logical', 'logical', 'logical', 'logical', 'logical', 'character', 'character', 'logical', 'logical', 'logical', 'logical', 'logical', 'logical', 'character', 'logical', '_p_VectorT_double_t', 'integer', 'logical', 'logical', 'integer')
class(`fistaGraph`) = c("SWIGFunction", class('fistaGraph'))

# Start of proximalFlat

`proximalFlat` = function(alpha0, alpha, groups, num_threads, lambda1, lambda2, lambda3, intercept, resetflow, name_regul, verbose, pos, clever, eval, size_group, transpose)
{
  if (inherits(alpha0, "ExternalReference")) alpha0 = slot(alpha0,"ref") 
  if (inherits(alpha, "ExternalReference")) alpha = slot(alpha,"ref") 
  if (inherits(groups, "ExternalReference")) groups = slot(groups,"ref") 
  num_threads = as.integer(num_threads);
  
  if(length(num_threads) > 1) {
    warning("using only the first element of num_threads");
  };
  
  
  
  
  intercept = as.logical(intercept);
  resetflow = as.logical(resetflow);
  name_regul = as(name_regul, "character"); 
  verbose = as.logical(verbose);
  pos = as.logical(pos);
  clever = as.logical(clever);
  eval = as.logical(eval);
  size_group = as.integer(size_group);
  
  if(length(size_group) > 1) {
    warning("using only the first element of size_group");
  };
  
  transpose = as.logical(transpose);
  ;ans = .Call('R_swig_proximalFlat', alpha0, alpha, groups, num_threads, lambda1, lambda2, lambda3, intercept, resetflow, name_regul, verbose, pos, clever, eval, size_group, transpose, PACKAGE='spams');
  #ans <- new("_p_VectorT_double_t", ref=ans) ;
  
  ans
  
}

attr(`proximalFlat`, 'returnType') = '_p_VectorT_double_t'
attr(`proximalFlat`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_VectorT_int_t', 'integer', 'numeric', 'numeric', 'numeric', 'logical', 'logical', 'character', 'logical', 'logical', 'logical', 'logical', 'integer', 'logical')
class(`proximalFlat`) = c("SWIGFunction", class('proximalFlat'))

# Start of proximalTree

`proximalTree` = function(alpha0, alpha, eta_g, groups, own_variables, N_own_variables, num_threads, lambda1, lambda2, lambda3, intercept, resetflow, name_regul, verbose, pos, clever, eval, size_group, transpose)
{
  if (inherits(alpha0, "ExternalReference")) alpha0 = slot(alpha0,"ref") 
  if (inherits(alpha, "ExternalReference")) alpha = slot(alpha,"ref") 
  if (inherits(eta_g, "ExternalReference")) eta_g = slot(eta_g,"ref") 
  if (inherits(groups, "ExternalReference")) groups = slot(groups,"ref") 
  if (inherits(own_variables, "ExternalReference")) own_variables = slot(own_variables,"ref") 
  if (inherits(N_own_variables, "ExternalReference")) N_own_variables = slot(N_own_variables,"ref") 
  num_threads = as.integer(num_threads);
  
  if(length(num_threads) > 1) {
    warning("using only the first element of num_threads");
  };
  
  
  
  
  intercept = as.logical(intercept);
  resetflow = as.logical(resetflow);
  name_regul = as(name_regul, "character"); 
  verbose = as.logical(verbose);
  pos = as.logical(pos);
  clever = as.logical(clever);
  eval = as.logical(eval);
  size_group = as.integer(size_group);
  
  if(length(size_group) > 1) {
    warning("using only the first element of size_group");
  };
  
  transpose = as.logical(transpose);
  ;ans = .Call('R_swig_proximalTree', alpha0, alpha, eta_g, groups, own_variables, N_own_variables, num_threads, lambda1, lambda2, lambda3, intercept, resetflow, name_regul, verbose, pos, clever, eval, size_group, transpose, PACKAGE='spams');
  #ans <- new("_p_VectorT_double_t", ref=ans) ;
  
  ans
  
}

attr(`proximalTree`, 'returnType') = '_p_VectorT_double_t'
attr(`proximalTree`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_VectorT_double_t', '_p_SpMatrixT_bool_t', '_p_VectorT_int_t', '_p_VectorT_int_t', 'integer', 'numeric', 'numeric', 'numeric', 'logical', 'logical', 'character', 'logical', 'logical', 'logical', 'logical', 'integer', 'logical')
class(`proximalTree`) = c("SWIGFunction", class('proximalTree'))

# Start of proximalGraph

`proximalGraph` = function(alpha0, alpha, eta_g, groups, groups_var, num_threads, lambda1, lambda2, lambda3, intercept, resetflow, name_regul, verbose, pos, clever, eval, size_group, transpose)
{
  if (inherits(alpha0, "ExternalReference")) alpha0 = slot(alpha0,"ref") 
  if (inherits(alpha, "ExternalReference")) alpha = slot(alpha,"ref") 
  if (inherits(eta_g, "ExternalReference")) eta_g = slot(eta_g,"ref") 
  if (inherits(groups, "ExternalReference")) groups = slot(groups,"ref") 
  if (inherits(groups_var, "ExternalReference")) groups_var = slot(groups_var,"ref") 
  num_threads = as.integer(num_threads);
  
  if(length(num_threads) > 1) {
    warning("using only the first element of num_threads");
  };
  
  
  
  
  intercept = as.logical(intercept);
  resetflow = as.logical(resetflow);
  name_regul = as(name_regul, "character"); 
  verbose = as.logical(verbose);
  pos = as.logical(pos);
  clever = as.logical(clever);
  eval = as.logical(eval);
  size_group = as.integer(size_group);
  
  if(length(size_group) > 1) {
    warning("using only the first element of size_group");
  };
  
  transpose = as.logical(transpose);
  ;ans = .Call('R_swig_proximalGraph', alpha0, alpha, eta_g, groups, groups_var, num_threads, lambda1, lambda2, lambda3, intercept, resetflow, name_regul, verbose, pos, clever, eval, size_group, transpose, PACKAGE='spams');
  #ans <- new("_p_VectorT_double_t", ref=ans) ;
  
  ans
  
}

attr(`proximalGraph`, 'returnType') = '_p_VectorT_double_t'
attr(`proximalGraph`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', '_p_VectorT_double_t', '_p_SpMatrixT_bool_t', '_p_SpMatrixT_bool_t', 'integer', 'numeric', 'numeric', 'numeric', 'logical', 'logical', 'character', 'logical', 'logical', 'logical', 'logical', 'integer', 'logical')
class(`proximalGraph`) = c("SWIGFunction", class('proximalGraph'))

# Start of simpleGroupTree

`simpleGroupTree` = function(degr, n)
{
  degr = as.integer(degr);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;ans = .Call('R_swig_simpleGroupTree', degr, n, PACKAGE='spams');
  #ans <- new("_p_std__vectorT_StructNodeElemT_double_t_p_t", ref=ans) ;
  
  ans
  
}

attr(`simpleGroupTree`, 'returnType') = '_p_std__vectorT_StructNodeElemT_double_t_p_t'
attr(`simpleGroupTree`, "inputTypes") = c('integer', 'integer')
class(`simpleGroupTree`) = c("SWIGFunction", class('simpleGroupTree'))

# Start of readGroupStruct

`readGroupStruct` = function(file)
{
  file = as(file, "character"); 
  ;ans = .Call('R_swig_readGroupStruct', file, PACKAGE='spams');
  #ans <- new("_p_std__vectorT_StructNodeElemT_double_t_p_t", ref=ans) ;
  
  ans
  
}

attr(`readGroupStruct`, 'returnType') = '_p_std__vectorT_StructNodeElemT_double_t_p_t'
attr(`readGroupStruct`, "inputTypes") = c('character')
class(`readGroupStruct`) = c("SWIGFunction", class('readGroupStruct'))

# Start of groupStructOfString

`groupStructOfString` = function(data)
{
  data = as(data, "character"); 
  ;ans = .Call('R_swig_groupStructOfString', data, PACKAGE='spams');
  #ans <- new("_p_std__vectorT_StructNodeElemT_double_t_p_t", ref=ans) ;
  
  ans
  
}

attr(`groupStructOfString`, 'returnType') = '_p_std__vectorT_StructNodeElemT_double_t_p_t'
attr(`groupStructOfString`, "inputTypes") = c('character')
class(`groupStructOfString`) = c("SWIGFunction", class('groupStructOfString'))

# Start of graphOfGroupStruct

`graphOfGroupStruct` = function(gstruct)
{
  if (inherits(gstruct, "ExternalReference")) gstruct = slot(gstruct,"ref") 
  ;ans = .Call('R_swig_graphOfGroupStruct', gstruct, PACKAGE='spams');
  #ans <- new("_p_VectorT_double_t", ref=ans) ;
  
  ans
  
}

attr(`graphOfGroupStruct`, 'returnType') = '_p_VectorT_double_t'
attr(`graphOfGroupStruct`, "inputTypes") = c('_p_std__vectorT_StructNodeElemT_double_t_p_t')
class(`graphOfGroupStruct`) = c("SWIGFunction", class('graphOfGroupStruct'))

# Start of treeOfGroupStruct

`treeOfGroupStruct` = function(gstruct, .copy = FALSE)
{
  if (inherits(gstruct, "ExternalReference")) gstruct = slot(gstruct,"ref") 
  ;.Call('R_swig_treeOfGroupStruct', gstruct, as.logical(.copy), PACKAGE='spams');
  
}

attr(`treeOfGroupStruct`, 'returnType') = 'integer'
attr(`treeOfGroupStruct`, "inputTypes") = c('_p_std__vectorT_StructNodeElemT_double_t_p_t')
class(`treeOfGroupStruct`) = c("SWIGFunction", class('treeOfGroupStruct'))

# Start of im2col_sliding

`im2col_sliding` = function(A, B, m, n, RGB)
{
  if (inherits(A, "ExternalReference")) A = slot(A,"ref") 
  if (inherits(B, "ExternalReference")) B = slot(B,"ref") 
  m = as.integer(m);
  
  if(length(m) > 1) {
    warning("using only the first element of m");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  RGB = as.logical(RGB);
  ;.Call('R_swig_im2col_sliding', A, B, m, n, RGB, PACKAGE='spams');
  
}

attr(`im2col_sliding`, 'returnType') = 'void'
attr(`im2col_sliding`, "inputTypes") = c('_p_MatrixT_double_t', '_p_MatrixT_double_t', 'integer', 'integer', 'logical')
class(`im2col_sliding`) = c("SWIGFunction", class('im2col_sliding'))


